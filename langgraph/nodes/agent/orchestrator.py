"""
Agent Orchestrator Node

Manages the flow and transitions between agent nodes.
Acts as the central routing logic for the agent graph.
"""

import logging
from typing import Dict, Any

# Configure logging
logger = logging.getLogger(__name__)

# Constants
MAX_RETRIES = 3
END = "__end__"


def orchestrator_node(state: Dict[str, Any]) -> None:
    """
    Agent Orchestrator Node
    
    Routes between agent nodes based on the current state.
    Updates next_node to indicate where the flow should go.
    
    Flow:
    1. Entry (from supervisor) → trigger_analysis
    2. After trigger_analysis → decision_maker OR END (if no trigger)
    3. After decision_maker → text_generator OR END (if no action)
    4. After text_generator → styler
    5. After styler → validator
    6. After validator → text_generator (retry) OR END (approved/max retries)
    
    Args:
        state: AgentState dict
    """
    current_node = state.get('current_node')
    
    logger.info(f"Orchestrator running - current_node: {current_node}")
    
    # Entry point - first node to run
    if current_node is None or current_node == 'orchestrator':
        logger.info("→ Routing to trigger_analysis (entry point)")
        state['current_node'] = 'orchestrator'
        state['next_node'] = 'trigger_analysis'
        return
    
    # After trigger analysis
    if current_node == 'trigger_analysis':
        detected_trigger = state.get('detected_trigger')
        agent_type = state.get('agent_type', 'unknown')
        agent_name = state.get('selected_persona', {}).get('agent_name', 'unknown')
        
        if detected_trigger is None:
            logger.info("→ No trigger detected - routing to END (no action needed)")
            state['selected_action'] = {
                "status": "no_action_needed",
                "reason": "no_trigger_detected",
                "agent_type": agent_type,
                "agent_name": agent_name
            }
            state['current_node'] = 'orchestrator'
            state['next_node'] = END
            return
        
        # Check for neutral trigger
        trigger_id = detected_trigger.get('id', '')
        if trigger_id == 'neutral' or 'neutral' in trigger_id.lower():
            logger.info("→ Neutral trigger detected - routing to END (no action needed)")
            state['selected_action'] = {
                "status": "no_action_needed",
                "reason": "neutral_trigger",
                "agent_type": agent_type,
                "agent_name": agent_name
            }
            state['current_node'] = 'orchestrator'
            state['next_node'] = END
            return
        
        logger.info(f"→ Trigger detected: {trigger_id} - routing to decision_maker")
        state['current_node'] = 'orchestrator'
        state['next_node'] = 'decision_maker'
        return
    
    # After decision maker
    if current_node == 'decision_maker':
        selected_action = state.get('selected_action')
        agent_type = state.get('agent_type', 'unknown')
        agent_name = state.get('selected_persona', {}).get('agent_name', 'unknown')
        
        if selected_action is None:
            logger.info("→ No action selected - routing to END (no action needed)")
            state['selected_action'] = {
                "status": "no_action_needed",
                "reason": "no_action_selected",
                "agent_type": agent_type,
                "agent_name": agent_name
            }
            state['current_node'] = 'orchestrator'
            state['next_node'] = END
            return
        
        action_id = selected_action.get('id', '')
        logger.info(f"→ Action selected: {action_id} - routing to text_generator")
        state['current_node'] = 'orchestrator'
        state['next_node'] = 'text_generator'
        return
    
    # After text generator (E.1)
    if current_node == 'text_generator':
        generated_response = state.get('generated_response')
        agent_type = state.get('agent_type', 'unknown')
        agent_name = state.get('selected_persona', {}).get('agent_name', 'unknown')
        
        if not generated_response:
            logger.error("→ Text generation failed - routing to END with error")
            state['selected_action'] = {
                "status": "error",
                "reason": "text_generation_failed",
                "error": "No response generated by E.1",
                "agent_type": agent_type,
                "agent_name": agent_name
            }
            state['current_node'] = 'orchestrator'
            state['next_node'] = END
            return
        
        logger.info("→ Text generated successfully - routing to styler")
        state['current_node'] = 'orchestrator'
        state['next_node'] = 'styler'
        return
    
    # After styler (E.2)
    if current_node == 'styler':
        styled_response = state.get('styled_response')
        agent_type = state.get('agent_type', 'unknown')
        agent_name = state.get('selected_persona', {}).get('agent_name', 'unknown')
        
        if not styled_response:
            logger.error("→ Styling failed - routing to END with error")
            state['selected_action'] = {
                "status": "error",
                "reason": "styling_failed",
                "error": "No styled response generated by E.2",
                "agent_type": agent_type,
                "agent_name": agent_name
            }
            state['current_node'] = 'orchestrator'
            state['next_node'] = END
            return
        
        logger.info("→ Response styled successfully - routing to validator")
        state['current_node'] = 'orchestrator'
        state['next_node'] = 'validator'
        return
    
    # After validator
    if current_node == 'validator':
        validation = state.get('validation', {})
        approved = validation.get('approved', False)
        retry_count = state.get('retry_count', 0)
        agent_type = state.get('agent_type', 'unknown')
        agent_name = state.get('selected_persona', {}).get('agent_name', 'unknown')
        
        if approved:
            logger.info("✓ Validation PASSED - routing to END")
            # Ensure selected_action has the final styled_response and agent info
            if state.get('selected_action'):
                state['selected_action']['status'] = 'success'
                state['selected_action']['styled_response'] = state.get('styled_response')
                state['selected_action']['agent_type'] = agent_type
                state['selected_action']['agent_name'] = agent_name
            state['retry_count'] = 0  # Reset for next action
            state['current_node'] = 'orchestrator'
            state['next_node'] = END
            return
        
        # Validation failed - check retry count
        explanation = validation.get('explanation', 'Unknown validation failure')
        
        if retry_count >= MAX_RETRIES:
            logger.warning(f"✗ Max retries ({MAX_RETRIES}) reached - routing to END with last attempt")
            # Return the last attempt even though it failed validation
            if state.get('selected_action'):
                state['selected_action']['status'] = 'max_retries_reached'
                state['selected_action']['styled_response'] = state.get('styled_response')
                state['selected_action']['validation_note'] = f"Failed validation after {MAX_RETRIES} attempts"
                state['selected_action']['agent_type'] = agent_type
                state['selected_action']['agent_name'] = agent_name
            state['retry_count'] = 0  # Reset for next action
            state['current_node'] = 'orchestrator'
            state['next_node'] = END
            return
        
        logger.warning(f"✗ Validation FAILED (attempt {retry_count}/{MAX_RETRIES}): {explanation}")
        logger.info("→ Routing back to text_generator for retry")
        state['current_node'] = 'orchestrator'
        state['next_node'] = 'text_generator'
        return
    
    # Unknown state - error handling
    logger.error(f"→ Unknown current_node: {current_node} - routing to END with error")
    agent_type = state.get('agent_type', 'unknown')
    agent_name = state.get('selected_persona', {}).get('agent_name', 'unknown')
    state['selected_action'] = {
        "status": "error",
        "reason": "unknown_state",
        "error": f"Orchestrator encountered unknown state: {current_node}",
        "agent_type": agent_type,
        "agent_name": agent_name
    }
    state['current_node'] = 'orchestrator'
    state['next_node'] = END


def route_from_orchestrator(state: Dict[str, Any]) -> str:
    """
    Routing function for LangGraph conditional edges.
    Returns the next_node value set by the orchestrator.
    
    Args:
        state: AgentState dict
        
    Returns:
        str: Next node name or END
    """
    next_node = state.get('next_node', END)
    logger.info(f"Routing from orchestrator to: {next_node}")
    return next_node
